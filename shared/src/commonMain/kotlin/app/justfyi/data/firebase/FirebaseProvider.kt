package app.justfyi.data.firebase

import kotlinx.coroutines.flow.Flow

/**
 * Common interface for Firebase operations.
 * This abstraction allows repository implementations to use Firebase
 * in commonMain while the actual implementation uses GitLive SDK
 * which works on both Android and iOS.
 *
 * The interface provides:
 * - Authentication operations (anonymous sign-in)
 * - Firestore document CRUD operations
 * - Firestore collection queries
 * - Cloud Functions invocation
 * - FCM token management
 */
interface FirebaseProvider {
    // ==================== Initialization ====================

    /**
     * Initializes Firebase services.
     * Must be called before any other Firebase operations.
     * Platform-specific initialization is handled internally.
     */
    suspend fun initialize()

    /**
     * Returns whether Firebase has been initialized.
     */
    fun isInitialized(): Boolean

    // ==================== Authentication ====================

    /**
     * Signs in anonymously and returns the anonymous user ID.
     * If already signed in, returns the current user's ID.
     *
     * @return The anonymous user ID, or null if sign-in failed
     */
    suspend fun signInAnonymously(): String?

    /**
     * Returns whether a user is currently authenticated.
     */
    fun isAuthenticated(): Boolean

    /**
     * Gets the current authenticated user's ID.
     *
     * @return The user ID, or null if not authenticated
     */
    fun getCurrentUserId(): String?

    /**
     * Signs out the current user.
     */
    suspend fun signOut()

    /**
     * Signs in with a custom token (used for account recovery).
     * This allows authenticating as a specific user ID.
     *
     * @param customToken The custom token generated by a Cloud Function
     * @return The user ID if successful, null if sign-in failed
     */
    suspend fun signInWithCustomToken(customToken: String): String?

    // ==================== Firestore Document Operations ====================

    /**
     * Sets a document in Firestore.
     * If the document exists, it will be overwritten or merged based on merge parameter.
     *
     * @param collection The collection path
     * @param documentId The document ID
     * @param data The document data as a map
     * @param merge If true, merge with existing document; if false, overwrite
     * @throws FirebaseException if the operation fails
     */
    suspend fun setDocument(
        collection: String,
        documentId: String,
        data: Map<String, Any?>,
        merge: Boolean = true,
    )

    /**
     * Gets a document from Firestore.
     *
     * @param collection The collection path
     * @param documentId The document ID
     * @return The document data as a map, or null if not found
     */
    suspend fun getDocument(
        collection: String,
        documentId: String,
    ): Map<String, Any?>?

    /**
     * Updates specific fields in a document.
     *
     * @param collection The collection path
     * @param documentId The document ID
     * @param updates The fields to update
     * @throws FirebaseException if the operation fails or document doesn't exist
     */
    suspend fun updateDocument(
        collection: String,
        documentId: String,
        updates: Map<String, Any?>,
    )

    /**
     * Deletes a document from Firestore.
     *
     * @param collection The collection path
     * @param documentId The document ID
     */
    suspend fun deleteDocument(
        collection: String,
        documentId: String,
    )

    // ==================== Firestore Collection Queries ====================

    /**
     * Queries a collection with a where clause.
     *
     * @param collection The collection path
     * @param whereField The field to filter on
     * @param whereValue The value to match
     * @param orderByField Optional field to order results by
     * @param descending If true, order descending; if false, ascending
     * @return List of documents matching the query
     */
    suspend fun queryCollection(
        collection: String,
        whereField: String,
        whereValue: Any,
        orderByField: String? = null,
        descending: Boolean = true,
    ): List<Map<String, Any?>>

    /**
     * Listens to real-time updates on a collection query.
     *
     * @param collection The collection path
     * @param whereField The field to filter on
     * @param whereValue The value to match
     * @return Flow of document lists that emits on every change
     */
    fun observeCollection(
        collection: String,
        whereField: String,
        whereValue: Any,
    ): Flow<List<DocumentSnapshot>>

    /**
     * Stops listening to a specific collection query.
     *
     * @param collection The collection path
     * @param whereField The field that was filtered on
     * @param whereValue The value that was matched
     */
    fun removeCollectionListener(
        collection: String,
        whereField: String,
        whereValue: Any,
    )

    // ==================== Cloud Functions ====================

    /**
     * Calls a Cloud Function.
     *
     * @param functionName The name of the function to call
     * @param data The data to pass to the function
     * @return The function result as a map, or null if no result
     * @throws FirebaseException if the function call fails
     */
    suspend fun callFunction(
        functionName: String,
        data: Map<String, Any?>,
    ): Map<String, Any?>?

    // ==================== Cloud Messaging ====================

    /**
     * Gets the current FCM token for push notifications.
     *
     * @return The FCM token, or null if not available
     */
    suspend fun getFcmToken(): String?
}

/**
 * Represents a Firestore document snapshot.
 */
data class DocumentSnapshot(
    val id: String,
    val data: Map<String, Any?>,
)

/**
 * Exception thrown when Firebase operations fail.
 */
class FirebaseException(
    message: String,
    cause: Throwable? = null,
) : Exception(message, cause)
